---
title: Creating Configuration Classes
layout: page
parent: Workflows
nav_order: 1
---

# Creating Configuration Classes
{: .no_toc }
A configuration class is where the functionality and parametrization of a simulation is defined.
This page is a step-by-step guide on how to create a configuration class.

## Page Contents
{: .no_toc .text-delta }
- TOC
{:toc}

## Create Class Definition File
The files associated with a configuration class should be placed within the `UserFiles/Configurations` directory.
If you are expecting not to create just one configuration class but a tree of related classes, you might want to create a MATLAB namespace directory (that starts with a `+` sign) within `UserFiles/Configurations` to group all the classes together.

The methods of a class can either be implemented directly inside the class definition file or be split into separate files.
For new classes that implement all the methods themselves, it is recommended to go with the latter approach.
For that, create a new directory with a name of the format `@MyNewConfiguration`, where `MyNewConfiguration` can be replaced with the name of your configuration class.
Inside this directory, create the class definition file with the same name (omitting the `@` sign this time) `MyNewConfiguration.m`.

Configuration classes must inherit from the abstract superclass `SimulationConfiguration` which needs to be specified in the first line of the class definition file.
The following expandable code block shows the full code of the class definition file.
The content is explained in the following sections.

{: .code_block }
> <details closed markdown="block">
> <summary>MyNewConfiguration.m</summary>
> ```matlab
> classdef MyNewConfiguration < SimulationConfiguration
> 
>     methods (Static)
> 
>         Parameters = configureParameters(obj)
> 
>         BusesInfo = configureBuses(Parameters)
> 
>         [EnvironmentConditions, ...
>             LogEnvironment, ...
>             EnvironmentStatesDerivatives] ...
>             = environment(EnvironmentConditions, ...
>                             LogEnvironment, ...
>                             EnvironmentStatesDerivatives, ...
>                             PlantOutputs, ...
>                             simulation_time__s, ...
>                             EnvironmentStates, ...
>                             ParametersEnvironment)
>         
>         [SensorsOutputs, ...
>             LogSensors, ...
>             StatesUpdateInput] ...
>             = sensors(SensorsOutputs, ...
>                         LogSensors, ...
>                         EnvironmentConditions, ...
>                         PlantOutputs, ...
>                         PlantFeedthrough, ...
>                         SensorsStates, ...
>                         ParametersSatellite)
> 
>         [ActuatorsOutputs,...
>             LogActuators, ...
>             StatesUpdateInput] ...
>             = actuators(ActuatorsOutputs, ...
>                         LogActuators, ...
>                         EnvironmentConditions, ...
>                         DynamicsOutputs, ...
>                         ActuatorsCommands, ...
>                         ActuatorsStates, ...
>                         ParametersSatellite)
>                                 
>         [PlantFeedthrough, ...
>             LogPlantDynamics, ...    
>             PlantStatesDerivatives] ...
>             = plantDynamics(PlantFeedthrough, ...
>                                 LogPlantDynamics, ...
>                                 EnvironmentConditions, ...
>                                 ActuatorsOutputs, ...
>                                 PlantStates, ...
>                                 ParametersSatellite)
> 
>         [PlantOutputs, ...
>             LogPlantOutput] ...
>             = plantOutput(PlantOutputs, ...
>                             LogPlantOutput, ...
>                             PlantStates, ...
>                             ParametersSatellite)
> 
>         [ActuatorsCommands, ...
>             LogGncAlgorithms, ...
>             StatesUpdateInput] ...
>             = gncAlgorithms(ActuatorsCommands, ...
>                             LogGncAlgorithms, ...
>                             SensorsOutputs, ...
>                             GncAlgorithmsStates, ...
>                             ParametersGncAlgorithms)
> 
>         [udp_data_vector, LogSendSimData] ...
>             = sendSimData(LogSendSimData, ...
>                             simulation_time__s, ...
>                             LogEnvironment, ...
>                             LogSensors, ...
>                             LogActuators, ...
>                             LogPlantDynamics, ...
>                             LogPlantOutput,...
>                             LogGncAlgorithms, ...
>                             Parameters)
> 
>         [stop_criterion, LogStopCriterion] ...
>             = stopCriterion(LogStopCriterion, ...
>                             simulation_time__s, ...
>                             LogEnvironment, ...
>                             LogSensors, ...
>                             LogActuators, ...
>                             LogPlantDynamics, ...
>                             LogPlantOutput,...
>                             LogGncAlgorithms, ...
>                             Parameters)
> 
>     end
> 
> end
> </details>
> ```

## Implement Subsystem Functions
The abstract superclass forces the subclasses to implement the following static methods which are called in the Simulink subsystems:
- `environment`
- `sensors`
- `actuators`
- `plantDynamics`
- `plantOutput`
- `gncAlgorithms`
- `sendSimData`
- `stopCriterion`

The class definition file above lists their signatures.
The actual implementation is done in individual files within the class folder.
For that, create a new file for each method with the same name as the method, copy the method signature into the file, and implement the desired behavior of the subsystem function.
E.g., for the `environment` method, create a file `environment.m` with the following content:

{: .code_block }
> <details closed markdown="block">
> <summary>environment.m</summary>
> ```matlab
> function [EnvironmentConditions, ...
>             LogEnvironment, ...
>             EnvironmentStatesDerivatives] ...
>             = environment(EnvironmentConditions, ...
>                             LogEnvironment, ...
>                             EnvironmentStatesDerivatives, ...
>                             PlantOutputs, ...
>                             simulation_time__s, ...
>                             EnvironmentStates, ...
>                             ParametersEnvironment)
> 
> % Actual Implementation of Subsystem Function Behavior
> 
> end
> ```
> </details>

For the actual implementation, you can make use of the models library provided in the `Core` directory.
Familiarize yourself with a model's implementation and call the static method `execute` inside the subsystem function.
The page [Subsystem Functions]({% link content/setup/subsystem_functions.md %}) provides a detailed explanation.

Instead of relying on pre-defined models, you can also use custom functionality by either using your own models that you added to the `UserFiles/Models` directory according to the description in [Adding New Models]({% link content/workflows/adding_models.md %}) or by explicitly coding custom functionality inside the subsystem function.

## Implement Configuration Methods
### `configureParameters`
SADYCOS needs to know general settings like the simulation duration to run a simulation.
Furthermore, the models you use inside the subsystem functions often require constant parameters to be set.
Both these things are done in the static method `configureParameters` whose signature was already listed in the class definition file.

Create a new file `configureParameters.m` within the class folder and implement the method.
You are advised to use the utility class `ParameterCreator` provided in `Core/Utilities` to aid in creating a correctly formatted parameter structure.
See the page [Parameter Configuration]({% link content/setup/parameters.md %}) for a detailed explanation.

### `configureBuses`
The static method `configureBuses` must be implemented to define the bus objects that are used to specify the format of the bus signals in the Simulink model.
Its signature is also shown the class definition file above.
Create a new file `configureBuses.m` within the class folder and implement the method.
You are advised to use the utility class `BusesInfoCreator` provided in `Core/Utilities` to aid in creating a correctly formatted bus structure.
See the page [Bus Configuration]({% link content/setup/buses.md %}) for a detailed explanation.

## Optional: Implement Custom Methods
You can add custom methods to the configuration class to encapsulate further functionality that you might need.
For example, you can add methods that aid in the analysis of the simulation results.
To do so, first, add the method signature to the class definition file.
Then, create a new file in the class folder with the method name and implement the desired behavior. 